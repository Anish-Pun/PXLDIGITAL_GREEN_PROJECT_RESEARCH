‚úÖ Wiring & mode setup

From your transmitter code you used:

M0 = GND, M1 = GND ‚Üí that corresponds to Normal mode of the E22/E32. 
mischianti.org
+2
Lloyd Rochester's Geek Blog
+2

TX/RX are connected via UART (Serial2 on ESP32).

The AUX pin you left unconnected (that‚Äôs usually okay but using it can help with busy status).

For the Raspberry Pi receiver you‚Äôll wire similarly:

Connect the module‚Äôs GND to the Pi‚Äôs GND.

Connect VCC to appropriate voltage (check the module‚Äôs spec: some are 3.3 V, some allow 5 V).

Connect the module‚Äôs TX ‚Üí Pi RX (e.g., /dev/ttyS0 or /dev/ttyAMA0)

Connect the module‚Äôs RX ‚Üí Pi TX

Connect M0 = GND, M1 = GND (to match ‚ÄúNormal‚Äù mode).

Optionally connect AUX pin to a GPIO if you want to monitor when module is busy.

For example your wiring on Pi could look like:

Module   ‚Üí Raspberry Pi  
VCC      ‚Üí 3.3 V (or 5 V if module supports)  
GND      ‚Üí GND  
TX       ‚Üí Pi UART RX pin (e.g. GPIO 15 or /dev/ttyAMA0)  
RX       ‚Üí Pi UART TX pin (e.g. GPIO 14)  
M0       ‚Üí GND  
M1       ‚Üí GND  
AUX      ‚Üí ‚Üí optionally e.g. GPIO for busy (can also leave unconnected)  


Ensure serial port on the Pi is enabled and not interfering with login console. 
Lloyd Rochester's Geek Blog
+1

Python code for the Pi receiver

Here‚Äôs an example Python script you can run on the Raspberry Pi to receive messages from your transmitter. You may need to install the Ebyte ‚ÄúE22/E32‚Äù library (there is one for E32 which also works for E22) or just use raw serial reading if you don‚Äôt want the library. I‚Äôll show the simpler raw serial version first.

import serial
import time

# Change these to match your setup:
SERIAL_PORT = '/dev/ttyAMA0'     # or '/dev/ttyS0', check your Pi version & configuration
BAUDRATE    = 9600               # must match the sender‚Äôs UART baud (in your ESP32 code it‚Äôs Serial.begin(9600))
TIMEOUT     = 1.0                # seconds

def main():
    try:
        ser = serial.Serial(port=SERIAL_PORT, baudrate=BAUDRATE, timeout=TIMEOUT)
        print(f"Listening on {SERIAL_PORT}, {BAUDRATE}bps")
    except serial.SerialException as e:
        print("Could not open serial port:", e)
        return

    while True:
        if ser.in_waiting:
            data = ser.read(ser.in_waiting)  # read all available
            try:
                text = data.decode('utf-8', errors='replace')
            except:
                text = repr(data)
            print("Received:", text)
        time.sleep(0.1)

if __name__ == '__main__':
    main()


Notes:

Make sure the port and baudrate match the transmitter side.

The ‚Äúin_waiting‚Äù method checks how many bytes are available.

If you want to process commands or send back replies, you can also use ser.write(...).

If you want to use the full protocol of the E22/E32 (for example reading status, configuring module, handling ‚ÄúResponseStatus‚Äù etc), you can use the Python library: EByte_LoRa_E22_python_raspberrypi_library (or the E32 equivalent). 
GitHub
+1

üîß Example using the library

If you want more control (e.g., configuration, checking module status, addresses, channels), you can use the library. The mischianti.org website has examples for E22/E32 under Python/MicroPython. 
mischianti.org
+1

Here‚Äôs a rough sketch using that library (adapted):

from lora_e32 import LoRaE32, Configuration
from lora_e32_operation_constant import ResponseStatusCode

# adjust pins if you use AUX/M0/M1 wired to Pi GPIOs
AUX_PIN = 17     # example
M0_PIN  = 27
M1_PIN  = 22

# create the LoRa object
lora = LoRaE32('433T20D', '/dev/ttyAMA0',
               aux_pin=AUX_PIN, m0_pin=M0_PIN, m1_pin=M1_PIN,
               debug=True)

# begin
code, conf = lora.begin()
print("Begin:", ResponseStatusCode.get_description(code))
if code != ResponseStatusCode.SUCCESS:
    print("Failed to init, code:", code)
    exit(1)

# optionally read configuration
code, config = lora.get_configuration()
print("GetConf:", ResponseStatusCode.get_description(code))
print(config)

# loop to receive
while True:
    if lora.available():
        rc = lora.receive_message()
        if rc.status.code != ResponseStatusCode.SUCCESS:
            print("Error:", rc.status.get_response_description())
        else:
            print("Received data:", rc.data)
    time.sleep(0.1)


Important: you must set the module configuration (addresses, channel, air data rate, fixed transmission mode) to match your transmitter‚Äôs settings. If these don‚Äôt match, you will not receive correctly. 
mischianti.org
+1

üö® Common pitfalls & tips

Serial port confusion: On newer Raspberry Pi models you may need to use /dev/ttyS0 or /dev/ttyAMA0 and disable the login shell on the serial. 
Lloyd Rochester's Geek Blog

Voltage levels: Ensure your module‚Äôs VCC and logic levels are correct. If the module is 5 V tolerant or 3.3 V only, you must adjust accordingly.

M0/M1 mode: If you don‚Äôt set both modules (Tx + Rx) in the same mode (Normal / WOR / Fixed / etc), you won‚Äôt get communication. From your transmitter M0=M1=GND (Normal) so the Rx must match that mode. 
mischianti.org
+1

Baud & air data rate: For UART they must match, and for the wireless side (air data) too. Different modules (433/868 MHz) may have different default channels.

Noise / wiring / antenna: Good wiring, proper antenna, minimal interference = better success. See the forum post about Raspberry Pi+E22 where wiring/corruption caused IndexError. 
mischianti.org

Debugging: Print out raw bytes, check for data like ‚ÄúHello, world?‚Äù that you sent. Use LED or AUX pin to check if module is busy.

Library version: If you use the library, ensure it supports your exact module version (E22 vs E32) and frequency. The GitHub project is for E22/E32: 
GitHub

If you like, I can find a full ready-to-run GitHub project for Raspberry Pi + E22/E32 (with wiring diagrams, scripts) and send you that. Do you want me to look up one specific for your module (E22) and for Raspberry Pi (e.g., Pi 4 or Zero)?